from mirascope import llm
import os
from pathlib import Path

# Get the current working directory (hard constraint: operations limited to this folder)
PROJECT_ROOT = os.getcwd()


def load_plan_prompt() -> str:
    """Load the plan prompt from a markdown file, with fallback to default.
    
    This follows the same pattern as mirascope_cli.py's load_base_prompt function.
    """
    # Navigate to prompts/plan.md relative to project root
    prompt_path = Path(PROJECT_ROOT) / "prompts" / "plan.md"
    if prompt_path.exists():
        with open(prompt_path, "r", encoding="utf-8") as f:
            return f.read()
    
    # Fallback to default prompt if file not found
    return """You are an expert task planner. Create a detailed, step-by-step plan for the following task:

TASK: {task}

CURRENT CONTEXT: {current_context if current_context else "No specific context provided."}

AVAILABLE TOOLS/CAPABILITIES: {available_tools if available_tools else "File operations (create, read, edit), bash execution, git operations, planning."}

Please analyze this task and create a comprehensive plan that:
1. Breaks down the task into specific, actionable steps
2. Considers the current context and constraints
3. Uses the available tools effectively
4. Identifies potential challenges and how to address them
5. Prioritizes steps logically
6. Includes verification points

Format your response as a structured plan with numbered steps, each including:
- Step number and brief title
- Clear description of what needs to be done
- Which tools or approaches to use
- Any dependencies or prerequisites

Include an estimated complexity level (Low/Medium/High) at the end.
"""


@llm.tool
def plan(task: str, current_context: str = "", available_tools: str = "") -> str:
    """Create a detailed plan for completing a task.
    
    This tool acts as a sub-agent that analyzes a task and creates a step-by-step plan
    for completion. It considers the current context and available tools to generate
    a realistic, actionable plan.
    
    Args:
        task: The main task or goal to plan for (clear and specific)
        current_context: Current situation, constraints, or background information
        available_tools: List of tools or capabilities available for executing the plan
    
    Returns:
        A structured plan with numbered steps, estimated complexity, and any considerations.
    """
    try:
        # Load the planning prompt template
        prompt_template = load_plan_prompt()
        
        # Build the final prompt with context
        prompt = prompt_template.format(
            task=task,
            current_context=current_context,
            available_tools=available_tools if available_tools else "File operations (create, read, edit), bash execution, git operations, planning."
        )

        # Use the main model to generate the plan
        model = llm.Model(
            "vllm/vllm",
            max_tokens=8196,
            thinking={"level": "high", "include_thoughts": True}
        )

        messages = [
            llm.messages.system("You are an expert task planner. Provide clear, actionable plans."),
            llm.messages.user(prompt),
        ]

        response = model.stream(messages)
        
        # Collect the full response
        plan_text = ""
        for stream in response.streams():
            match stream.content_type:
                case "text":
                    for chunk in stream:
                        plan_text += chunk
                case "thought":
                    # Thoughts are internal, don't include in plan output
                    pass
                case "tool_call":
                    # Shouldn't happen for planning, but handle gracefully
                    pass

        return f"## Plan for: {task}\n\n{plan_text}\n\n---\n*Generated by plan tool*"
        
    except Exception as e:
        return f"Error generating plan: {str(e)}\n\nPlease try rephrasing the task or providing more context."
